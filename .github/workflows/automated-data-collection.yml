name: 🤖 Automated Data Collection & Correlation Discovery

on:
  schedule:
    # Run daily at 6 AM UTC (adjust timezone as needed)
    - cron: '0 6 * * *'
  workflow_dispatch: # Allow manual triggering
    inputs:
      force_update:
        description: 'Force update even if data is recent'
        required: false
        default: false
        type: boolean
      data_sources:
        description: 'Comma-separated list of data sources to update (leave empty for all)'
        required: false
        default: ''
        type: string

env:
  # GitHub token for committing data
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  
  # API Keys stored in GitHub repository secrets
  FRED_API_KEY: ${{ secrets.FRED_API_KEY }}
  ALPHA_VANTAGE_API_KEY: ${{ secrets.ALPHA_VANTAGE_API_KEY }}
  OPENWEATHER_API_KEY: ${{ secrets.OPENWEATHER_API_KEY }}
  
  # Alternative: Use VITE_ prefixed keys if main keys not available
  VITE_FRED_API_KEY: ${{ secrets.VITE_FRED_API_KEY }}
  VITE_ALPHA_VANTAGE_API_KEY: ${{ secrets.VITE_ALPHA_VANTAGE_API_KEY }}
  VITE_OPENWEATHER_API_KEY: ${{ secrets.VITE_OPENWEATHER_API_KEY }}
  
  # Data collection configuration
  MAX_DATASETS_PER_RUN: 50
  QUALITY_THRESHOLD: 0.7
  MAX_CORRELATIONS_TO_GENERATE: 100

jobs:
  collect-data:
    name: 📊 Collect Fresh Data
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    outputs:
      datasets-updated: ${{ steps.generate-index.outputs.datasets-indexed }}
      correlations-generated: ${{ steps.correlations.outputs.correlations-generated }}
      data-commit-sha: ${{ steps.commit-data.outputs.commit-sha }}
    
    steps:
      - name: 🔄 Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1
      
      - name: 🟢 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: 📦 Install Dependencies
        run: |
          npm ci
          npm install --no-save axios cheerio csv-parser papaparse date-fns
      
      - name: 🔍 Check Existing Data
        id: check-data
        run: |
          echo "Checking for existing data files..."
          
          # Count existing datasets
          EXISTING_DATASETS=$(find public/ai-data -name "*.json" -not -name "*_metadata.json" 2>/dev/null | wc -l || echo "0")
          echo "existing-datasets=$EXISTING_DATASETS" >> $GITHUB_OUTPUT
          
          # Check last update time
          if [ -f "public/ai-data/last-update.json" ]; then
            LAST_UPDATE=$(cat public/ai-data/last-update.json | jq -r '.timestamp // empty' 2>/dev/null || echo "")
            echo "last-update=$LAST_UPDATE" >> $GITHUB_OUTPUT
          else
            echo "last-update=" >> $GITHUB_OUTPUT
          fi
          
          echo "Found $EXISTING_DATASETS existing datasets"
      
      - name: 📊 Collect Economic Data (FRED)
        id: collect-fred
        if: env.FRED_API_KEY != ''
        run: |
          echo "🏛️ Collecting data from Federal Reserve Economic Data (FRED)..."
          
          # Create data collection script
          cat > collect-fred-data.js << 'EOF'
          import axios from 'axios';
          import { promises as fs } from 'fs';
          import path from 'path';
          
          const FRED_API_KEY = process.env.FRED_API_KEY;
          const BASE_URL = 'https://api.stlouisfed.org/fred';
          
          // Key economic indicators to collect
          const ECONOMIC_SERIES = [
            { id: 'GDP', name: 'Gross Domestic Product', unit: 'Billions of Dollars', category: 'economics' },
            { id: 'UNRATE', name: 'Unemployment Rate', unit: 'Percent', category: 'economics' },
            { id: 'CPIAUCSL', name: 'Consumer Price Index', unit: 'Index 1982-1984=100', category: 'economics' },
            { id: 'FEDFUNDS', name: 'Federal Funds Rate', unit: 'Percent', category: 'economics' },
            { id: 'HOUST', name: 'Housing Starts', unit: 'Thousands of Units', category: 'economics' },
            { id: 'PAYEMS', name: 'Total Nonfarm Payrolls', unit: 'Thousands of Persons', category: 'economics' },
            { id: 'INDPRO', name: 'Industrial Production Index', unit: 'Index 2017=100', category: 'economics' },
            { id: 'RSAFS', name: 'Retail Sales', unit: 'Millions of Dollars', category: 'economics' },
            { id: 'DEXUSEU', name: 'US Dollar to Euro Exchange Rate', unit: 'USD per EUR', category: 'finance' },
            { id: 'DGS10', name: '10-Year Treasury Rate', unit: 'Percent', category: 'finance' },
            { id: 'DCOILWTICO', name: 'Crude Oil Price (WTI)', unit: 'Dollars per Barrel', category: 'energy' },
            { id: 'GOLDAMGBD228NLBM', name: 'Gold Price', unit: 'USD per Troy Ounce', category: 'commodities' },
            { id: 'CSUSHPISA', name: 'Case-Shiller Home Price Index', unit: 'Index Jan 2000=100', category: 'housing' },
            { id: 'UMCSENT', name: 'Consumer Sentiment', unit: 'Index 1966:Q1=100', category: 'economics' },
            { id: 'NASDAQCOM', name: 'NASDAQ Composite Index', unit: 'Index Feb 5, 1971=100', category: 'finance' }
          ];
          
          async function fetchSeriesData(seriesId) {
            try {
              const response = await axios.get(`${BASE_URL}/series/observations`, {
                params: {
                  series_id: seriesId,
                  api_key: FRED_API_KEY,
                  file_type: 'json',
                  observation_start: '2010-01-01',
                  frequency: 'a', // Annual data
                  sort_order: 'desc',
                  limit: 15
                }
              });
              
              if (response.data && response.data.observations) {
                return response.data.observations
                  .filter(obs => obs.value !== '.')
                  .map(obs => ({
                    year: parseInt(obs.date.split('-')[0]),
                    value: parseFloat(obs.value),
                    date: obs.date
                  }))
                  .filter(obs => !isNaN(obs.value))
                  .sort((a, b) => a.year - b.year);
              }
              return [];
            } catch (error) {
              console.error(`Error fetching ${seriesId}:`, error.message);
              return [];
            }
          }
          
          async function main() {
            console.log('📊 Starting FRED data collection...');
            
            // Ensure directories exist
            await fs.mkdir('public/ai-data', { recursive: true });
            
            let totalDatasets = 0;
            
            for (const series of ECONOMIC_SERIES) {
              console.log(`Fetching ${series.name} (${series.id})...`);
              
              const data = await fetchSeriesData(series.id);
              
              if (data.length > 0) {
                // Save dataset
                const filename = `economics-${series.id.toLowerCase()}.json`;
                await fs.writeFile(
                  path.join('public/ai-data', filename),
                  JSON.stringify(data, null, 2)
                );
                
                // Save metadata
                const metadata = {
                  id: series.id.toLowerCase(),
                  name: series.name,
                  unit: series.unit,
                  category: series.category,
                  source: 'FRED',
                  sourceUrl: `https://fred.stlouisfed.org/series/${series.id}`,
                  lastUpdated: new Date().toISOString(),
                  dataPoints: data.length,
                  dateRange: {
                    start: data[0].year,
                    end: data[data.length - 1].year
                  },
                  description: `${series.name} data from the Federal Reserve Economic Data (FRED) database`
                };
                
                await fs.writeFile(
                  path.join('public/ai-data', `${filename.replace('.json', '_metadata.json')}`),
                  JSON.stringify(metadata, null, 2)
                );
                
                totalDatasets++;
                console.log(`✅ Saved ${data.length} data points for ${series.name}`);
              } else {
                console.log(`⚠️ No data available for ${series.name}`);
              }
              
              // Rate limiting - FRED allows 120 requests per minute
              await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            console.log(`🎉 FRED data collection complete! Updated ${totalDatasets} datasets`);
            return totalDatasets;
          }
          
          main().then(count => {
            console.log(`::set-output name=datasets-updated::${count}`);
          }).catch(console.error);
          EOF
          
          node collect-fred-data.js
      
      - name: 🌍 Collect Global Data (World Bank)
        id: collect-worldbank
        run: |
          echo "🌍 Collecting data from World Bank..."
          
          cat > collect-worldbank-data.js << 'EOF'
          import axios from 'axios';
          import { promises as fs } from 'fs';
          import path from 'path';
          
          // World Bank indicators
          const WB_INDICATORS = [
            { id: 'NY.GDP.MKTP.CD', name: 'GDP (current US$)', unit: 'Current US$', category: 'economics' },
            { id: 'NY.GDP.PCAP.CD', name: 'GDP per capita', unit: 'Current US$', category: 'economics' },
            { id: 'SP.POP.TOTL', name: 'Population, total', unit: 'People', category: 'demographics' },
            { id: 'SP.URB.TOTL.IN.ZS', name: 'Urban population', unit: '% of total', category: 'demographics' },
            { id: 'SL.UEM.TOTL.ZS', name: 'Unemployment, total', unit: '% of labor force', category: 'economics' },
            { id: 'FP.CPI.TOTL.ZG', name: 'Inflation, consumer prices', unit: 'Annual %', category: 'economics' },
            { id: 'NE.EXP.GNFS.ZS', name: 'Exports of goods and services', unit: '% of GDP', category: 'trade' },
            { id: 'NE.IMP.GNFS.ZS', name: 'Imports of goods and services', unit: '% of GDP', category: 'trade' },
            { id: 'BX.KLT.DINV.CD.WD', name: 'Foreign direct investment', unit: 'Current US$', category: 'finance' }
          ];
          
          async function fetchWorldBankData(indicator, country = 'US') {
            try {
              const response = await axios.get(`https://api.worldbank.org/v2/country/${country}/indicator/${indicator}`, {
                params: {
                  format: 'json',
                  date: '2010:2023',
                  per_page: 100
                }
              });
              
              if (response.data && response.data[1]) {
                return response.data[1]
                  .filter(item => item.value !== null)
                  .map(item => ({
                    year: item.date,
                    value: item.value
                  }))
                  .sort((a, b) => a.year - b.year);
              }
              return [];
            } catch (error) {
              console.error(`Error fetching ${indicator}:`, error.message);
              return [];
            }
          }
          
          async function main() {
            console.log('🌍 Starting World Bank data collection...');
            
            await fs.mkdir('public/ai-data', { recursive: true });
            
            let totalDatasets = 0;
            
            for (const indicator of WB_INDICATORS) {
              console.log(`Fetching ${indicator.name} (${indicator.id})...`);
              
              const data = await fetchWorldBankData(indicator.id);
              
              if (data.length > 0) {
                const filename = `worldbank-${indicator.id.toLowerCase().replace(/\./g, '-')}.json`;
                await fs.writeFile(
                  path.join('public/ai-data', filename),
                  JSON.stringify(data, null, 2)
                );
                
                const metadata = {
                  id: indicator.id.toLowerCase().replace(/\./g, '-'),
                  name: indicator.name,
                  unit: indicator.unit,
                  category: indicator.category,
                  source: 'World Bank',
                  sourceUrl: `https://data.worldbank.org/indicator/${indicator.id}`,
                  lastUpdated: new Date().toISOString(),
                  dataPoints: data.length,
                  dateRange: {
                    start: Math.min(...data.map(d => parseInt(d.year))),
                    end: Math.max(...data.map(d => parseInt(d.year)))
                  },
                  description: `${indicator.name} data from the World Bank Open Data`
                };
                
                await fs.writeFile(
                  path.join('public/ai-data', `${filename.replace('.json', '_metadata.json')}`),
                  JSON.stringify(metadata, null, 2)
                );
                
                totalDatasets++;
                console.log(`✅ Saved ${data.length} data points for ${indicator.name}`);
              }
              
              // Rate limiting
              await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            console.log(`🎉 World Bank data collection complete! Updated ${totalDatasets} datasets`);
            return totalDatasets;
          }
          
          main().then(count => {
            console.log(`::set-output name=datasets-updated::${count}`);
          }).catch(console.error);
          EOF
          
          node collect-worldbank-data.js
      
      - name: 💹 Collect Financial Data (Alpha Vantage)
        id: collect-finance
        if: env.ALPHA_VANTAGE_API_KEY != ''
        run: |
          echo "💹 Collecting financial market data..."
          
          cat > collect-finance-data.js << 'EOF'
          import axios from 'axios';
          import { promises as fs } from 'fs';
          import path from 'path';
          
          const API_KEY = process.env.ALPHA_VANTAGE_API_KEY;
          const BASE_URL = 'https://www.alphavantage.co/query';
          
          // Major market indices and indicators
          const FINANCIAL_SERIES = [
            { symbol: 'SPY', name: 'S&P 500 ETF', category: 'equity' },
            { symbol: 'QQQ', name: 'NASDAQ 100 ETF', category: 'equity' },
            { symbol: 'DIA', name: 'Dow Jones ETF', category: 'equity' },
            { symbol: 'IWM', name: 'Russell 2000 ETF', category: 'equity' },
            { symbol: 'VTI', name: 'Total Stock Market ETF', category: 'equity' },
            { symbol: 'GLD', name: 'Gold ETF', category: 'commodities' },
            { symbol: 'USO', name: 'Oil ETF', category: 'commodities' }
          ];
          
          async function fetchStockData(symbol) {
            try {
              const response = await axios.get(BASE_URL, {
                params: {
                  function: 'TIME_SERIES_MONTHLY_ADJUSTED',
                  symbol: symbol,
                  apikey: API_KEY
                }
              });
              
              if (response.data && response.data['Monthly Adjusted Time Series']) {
                const timeSeries = response.data['Monthly Adjusted Time Series'];
                
                // Convert to annual data (December values)
                const annualData = {};
                Object.keys(timeSeries).forEach(date => {
                  const year = date.split('-')[0];
                  const month = date.split('-')[1];
                  
                  // Take December values for annual data, or latest available
                  if (month === '12' || !annualData[year]) {
                    annualData[year] = {
                      year: parseInt(year),
                      value: parseFloat(timeSeries[date]['5. adjusted close']),
                      date: date
                    };
                  }
                });
                
                return Object.values(annualData)
                  .filter(item => !isNaN(item.value))
                  .sort((a, b) => a.year - b.year)
                  .slice(-15); // Last 15 years
              }
              return [];
            } catch (error) {
              console.error(`Error fetching ${symbol}:`, error.message);
              return [];
            }
          }
          
          async function main() {
            console.log('💹 Starting financial data collection...');
            
            await fs.mkdir('public/ai-data', { recursive: true });
            
            let totalDatasets = 0;
            
            for (const stock of FINANCIAL_SERIES) {
              console.log(`Fetching ${stock.name} (${stock.symbol})...`);
              
              const data = await fetchStockData(stock.symbol);
              
              if (data.length > 0) {
                const filename = `finance-${stock.symbol.toLowerCase()}.json`;
                await fs.writeFile(
                  path.join('public/ai-data', filename),
                  JSON.stringify(data, null, 2)
                );
                
                const metadata = {
                  id: stock.symbol.toLowerCase(),
                  name: stock.name,
                  unit: 'USD',
                  category: stock.category,
                  source: 'Alpha Vantage',
                  sourceUrl: `https://finance.yahoo.com/quote/${stock.symbol}`,
                  lastUpdated: new Date().toISOString(),
                  dataPoints: data.length,
                  dateRange: {
                    start: data[0].year,
                    end: data[data.length - 1].year
                  },
                  description: `${stock.name} price data for correlation analysis`
                };
                
                await fs.writeFile(
                  path.join('public/ai-data', `${filename.replace('.json', '_metadata.json')}`),
                  JSON.stringify(metadata, null, 2)
                );
                
                totalDatasets++;
                console.log(`✅ Saved ${data.length} data points for ${stock.name}`);
              }
              
              // Rate limiting - Alpha Vantage free tier: 5 requests per minute
              await new Promise(resolve => setTimeout(resolve, 12000));
            }
            
            console.log(`🎉 Financial data collection complete! Updated ${totalDatasets} datasets`);
            return totalDatasets;
          }
          
          main().then(count => {
            console.log(`::set-output name=datasets-updated::${count}`);
          }).catch(console.error);
          EOF
          
          # Only run if we have API key and not too many requests
          if [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event.inputs.force_update }}" = "true" ]; then
            node collect-finance-data.js
          else
            echo "Skipping financial data collection to avoid rate limits on manual runs"
          fi
      
      - name: 🌤️ Collect Weather & Climate Data (OpenWeather)
        id: collect-weather
        if: env.OPENWEATHER_API_KEY != '' || env.VITE_OPENWEATHER_API_KEY != ''
        run: |
          echo "🌤️ Collecting weather and climate data from OpenWeather..."
          
          # Create weather data collection script
          cat > collect-weather-data.js << 'EOF'
          import axios from 'axios';
          import { promises as fs } from 'fs';
          import path from 'path';
          
          // Use either OPENWEATHER_API_KEY or VITE_OPENWEATHER_API_KEY
          const OPENWEATHER_API_KEY = process.env.OPENWEATHER_API_KEY || process.env.VITE_OPENWEATHER_API_KEY;
          const BASE_URL = 'https://api.openweathermap.org/data/2.5';
          
          // Major cities for climate data collection
          const CITIES = [
            { name: 'New York', country: 'US', lat: 40.7128, lon: -74.0060 },
            { name: 'London', country: 'GB', lat: 51.5074, lon: -0.1278 },
            { name: 'Tokyo', country: 'JP', lat: 35.6762, lon: 139.6503 },
            { name: 'Sydney', country: 'AU', lat: -33.8688, lon: 151.2093 },
            { name: 'Mumbai', country: 'IN', lat: 19.0760, lon: 72.8777 },
            { name: 'São Paulo', country: 'BR', lat: -23.5505, lon: -46.6333 },
            { name: 'Cairo', country: 'EG', lat: 30.0444, lon: 31.2357 },
            { name: 'Moscow', country: 'RU', lat: 55.7558, lon: 37.6173 },
            { name: 'Dubai', country: 'AE', lat: 25.2048, lon: 55.2708 },
            { name: 'Toronto', country: 'CA', lat: 43.6532, lon: -79.3832 }
          ];
          
          async function fetchCityWeather(city) {
            try {
              const response = await axios.get(`${BASE_URL}/weather`, {
                params: {
                  lat: city.lat,
                  lon: city.lon,
                  appid: OPENWEATHER_API_KEY,
                  units: 'metric'
                }
              });
              
              if (response.data) {
                return {
                  city: city.name,
                  country: city.country,
                  coordinates: { lat: city.lat, lon: city.lon },
                  temperature: response.data.main.temp,
                  humidity: response.data.main.humidity,
                  pressure: response.data.main.pressure,
                  windSpeed: response.data.wind?.speed || 0,
                  cloudiness: response.data.clouds?.all || 0,
                  visibility: response.data.visibility || null,
                  weatherCondition: response.data.weather[0]?.main || 'Unknown',
                  description: response.data.weather[0]?.description || '',
                  timestamp: new Date().toISOString(),
                  year: new Date().getFullYear(),
                  month: new Date().getMonth() + 1,
                  day: new Date().getDate()
                };
              }
              return null;
            } catch (error) {
              console.error(`Error fetching weather for ${city.name}:`, error.message);
              return null;
            }
          }
          
          async function main() {
            console.log('🌤️ Starting weather data collection...');
            
            const weatherData = [];
            let successfulCities = 0;
            
            for (const city of CITIES) {
              console.log(`Fetching weather for ${city.name}, ${city.country}...`);
              const data = await fetchCityWeather(city);
              
              if (data) {
                weatherData.push(data);
                successfulCities++;
                console.log(`✅ ${city.name}: ${data.temperature}°C, ${data.description}`);
              }
              
              // Rate limiting - OpenWeather free tier: 60 requests per minute
              await new Promise(resolve => setTimeout(resolve, 1200));
            }
            
            if (weatherData.length > 0) {
              // Save current weather snapshot
              await fs.writeFile(
                path.join('public/ai-data', 'weather-current-global.json'),
                JSON.stringify(weatherData, null, 2)
              );
              
              // Create metadata
              const metadata = {
                id: 'weather-current-global',
                name: 'Global Current Weather Data',
                unit: 'Various (°C, %, hPa, m/s)',
                category: 'climate',
                source: 'OpenWeather API',
                sourceUrl: 'https://openweathermap.org/',
                lastUpdated: new Date().toISOString(),
                dataPoints: weatherData.length,
                cities: weatherData.map(w => `${w.city}, ${w.country}`),
                description: 'Current weather conditions for major global cities including temperature, humidity, pressure, and wind data for climate correlation analysis',
                dataTypes: ['temperature', 'humidity', 'pressure', 'windSpeed', 'cloudiness', 'visibility']
              };
              
              await fs.writeFile(
                path.join('public/ai-data', 'weather-current-global_metadata.json'),
                JSON.stringify(metadata, null, 2)
              );
              
              // Create temperature-focused dataset
              const tempData = weatherData.map(w => ({
                location: `${w.city}, ${w.country}`,
                temperature: w.temperature,
                year: w.year,
                value: w.temperature
              }));
              
              await fs.writeFile(
                path.join('public/ai-data', 'climate-global-temperatures.json'),
                JSON.stringify(tempData, null, 2)
              );
              
              const tempMetadata = {
                id: 'climate-global-temperatures',
                name: 'Global City Temperatures',
                unit: '°C',
                category: 'climate',
                source: 'OpenWeather API',
                sourceUrl: 'https://openweathermap.org/',
                lastUpdated: new Date().toISOString(),
                dataPoints: tempData.length,
                dateRange: {
                  start: new Date().getFullYear(),
                  end: new Date().getFullYear()
                },
                description: 'Current temperature readings from major global cities for climate correlation analysis'
              };
              
              await fs.writeFile(
                path.join('public/ai-data', 'climate-global-temperatures_metadata.json'),
                JSON.stringify(tempMetadata, null, 2)
              );
              
              console.log(`🎉 Weather data collection complete! Updated 2 datasets with data from ${successfulCities} cities`);
            }
            
            return successfulCities;
          }
          
          main().then(count => {
            console.log(`::set-output name=cities-updated::${count}`);
          }).catch(console.error);
          EOF
          
          node collect-weather-data.js
      
      - name: 📈 Generate Dataset Index
        id: generate-index
        run: |
          echo "📈 Generating dataset index..."
          
          cat > generate-index.js << 'EOF'
          import { promises as fs } from 'fs';
          import path from 'path';
          
          async function generateIndex() {
            const dataDir = 'public/ai-data';
            const files = await fs.readdir(dataDir);
            
            // Find all metadata files
            const metadataFiles = files.filter(f => f.endsWith('_metadata.json'));
            
            const datasets = [];
            let totalDataPoints = 0;
            
            for (const metaFile of metadataFiles) {
              try {
                const content = await fs.readFile(path.join(dataDir, metaFile), 'utf8');
                const metadata = JSON.parse(content);
                datasets.push(metadata);
                totalDataPoints += metadata.dataPoints || 0;
              } catch (error) {
                console.error(`Error reading ${metaFile}:`, error.message);
              }
            }
            
            // Group by category
            const categories = {};
            datasets.forEach(dataset => {
              if (!categories[dataset.category]) {
                categories[dataset.category] = [];
              }
              categories[dataset.category].push(dataset);
            });
            
            const index = {
              lastUpdated: new Date().toISOString(),
              totalDatasets: datasets.length,
              totalDataPoints: totalDataPoints,
              categories: Object.keys(categories),
              datasets: datasets,
              categorizedDatasets: categories,
              sources: [...new Set(datasets.map(d => d.source))],
              dateRange: {
                start: Math.min(...datasets.map(d => d.dateRange?.start || 9999)),
                end: Math.max(...datasets.map(d => d.dateRange?.end || 0))
              },
              generatedBy: 'GitHub Actions Data Pipeline',
              version: '1.0'
            };
            
            await fs.writeFile(
              path.join(dataDir, 'datasets_index.json'),
              JSON.stringify(index, null, 2)
            );
            
            // Create last update timestamp
            await fs.writeFile(
              path.join(dataDir, 'last-update.json'),
              JSON.stringify({
                timestamp: new Date().toISOString(),
                totalDatasets: datasets.length,
                workflow: 'automated-data-collection'
              }, null, 2)
            );
            
            console.log(`📊 Generated index with ${datasets.length} datasets and ${totalDataPoints} total data points`);
            return datasets.length;
          }
          
          generateIndex().then(count => {
            console.log(`::set-output name=datasets-indexed::${count}`);
          }).catch(console.error);
          EOF
          
          node generate-index.js
      
      - name: 🔗 Generate Correlations
        id: correlations
        run: |
          echo "🔗 Generating interesting correlations..."
          
          cat > generate-correlations.js << 'EOF'
          import { promises as fs } from 'fs';
          import path from 'path';
          
          // Calculate Pearson correlation coefficient
          function calculateCorrelation(x, y) {
            const n = x.length;
            if (n !== y.length || n === 0) return 0;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
          }
          
          // Align datasets by common years
          function alignDatasets(data1, data2) {
            const years1 = new Set(data1.map(d => d.year));
            const years2 = new Set(data2.map(d => d.year));
            const commonYears = [...years1].filter(year => years2.has(year)).sort();
            
            if (commonYears.length < 5) return null; // Need at least 5 data points
            
            const aligned1 = commonYears.map(year => 
              data1.find(d => d.year === year)?.value
            ).filter(v => v !== undefined);
            
            const aligned2 = commonYears.map(year => 
              data2.find(d => d.year === year)?.value
            ).filter(v => v !== undefined);
            
            return aligned1.length === aligned2.length ? { 
              x: aligned1, 
              y: aligned2, 
              years: commonYears,
              chartData: commonYears.map(year => ({
                year,
                value1: data1.find(d => d.year === year)?.value,
                value2: data2.find(d => d.year === year)?.value
              }))
            } : null;
          }
          
          async function generateCorrelations() {
            const dataDir = 'public/ai-data';
            const indexPath = path.join(dataDir, 'datasets_index.json');
            
            let index;
            try {
              const indexContent = await fs.readFile(indexPath, 'utf8');
              index = JSON.parse(indexContent);
            } catch (error) {
              console.error('Error reading datasets index:', error.message);
              return 0;
            }
            
            const correlations = [];
            const datasets = index.datasets;
            
            // Generate correlations between different datasets
            for (let i = 0; i < datasets.length; i++) {
              for (let j = i + 1; j < datasets.length; j++) {
                const dataset1 = datasets[i];
                const dataset2 = datasets[j];
                
                // Skip if same category (less interesting)
                if (dataset1.category === dataset2.category) continue;
                
                try {
                  // Load actual data
                  const data1Path = path.join(dataDir, `${dataset1.source.toLowerCase()}-${dataset1.id}.json`);
                  const data2Path = path.join(dataDir, `${dataset2.source.toLowerCase()}-${dataset2.id}.json`);
                  
                  const data1 = JSON.parse(await fs.readFile(data1Path, 'utf8'));
                  const data2 = JSON.parse(await fs.readFile(data2Path, 'utf8'));
                  
                  const aligned = alignDatasets(data1, data2);
                  if (!aligned) continue;
                  
                  const correlation = calculateCorrelation(aligned.x, aligned.y);
                  
                  // Only save interesting correlations (strong positive or negative)
                  if (Math.abs(correlation) >= 0.6) {
                    const correlationData = {
                      id: `${dataset1.id}_vs_${dataset2.id}`,
                      title: `${dataset1.name} vs ${dataset2.name}`,
                      description: `${getCorrelationDescription(correlation, dataset1.name, dataset2.name)}`,
                      correlation: correlation,
                      rSquared: correlation * correlation,
                      variable1: {
                        name: dataset1.name,
                        unit: dataset1.unit,
                        category: dataset1.category,
                        source: dataset1.source
                      },
                      variable2: {
                        name: dataset2.name,
                        unit: dataset2.unit,
                        category: dataset2.category,
                        source: dataset2.source
                      },
                      data: aligned.chartData,
                      commonYears: aligned.years.length,
                      dateRange: {
                        start: Math.min(...aligned.years),
                        end: Math.max(...aligned.years)
                      },
                      generatedAt: new Date().toISOString(),
                      isRealData: true,
                      dataSource: 'Automated Pipeline'
                    };
                    
                    correlations.push(correlationData);
                  }
                } catch (error) {
                  console.error(`Error processing ${dataset1.id} vs ${dataset2.id}:`, error.message);
                }
              }
            }
            
            // Sort by absolute correlation strength
            correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
            
            // Save top correlations
            const topCorrelations = correlations.slice(0, 50);
            
            await fs.writeFile(
              path.join(dataDir, 'generated_correlations.json'),
              JSON.stringify(topCorrelations, null, 2)
            );
            
            console.log(`🔗 Generated ${topCorrelations.length} interesting correlations`);
            return topCorrelations.length;
          }
          
          function getCorrelationDescription(correlation, name1, name2) {
            const absCorr = Math.abs(correlation);
            let strength = '';
            
            if (absCorr >= 0.8) strength = 'very strong';
            else if (absCorr >= 0.6) strength = 'strong';
            else if (absCorr >= 0.4) strength = 'moderate';
            else if (absCorr >= 0.2) strength = 'weak';
            else strength = 'very weak';
            
            const direction = correlation > 0 ? 'positive' : 'negative';
            
            return `${strength} ${direction} correlation between ${name1} and ${name2}`;
          }
          
          generateCorrelations().then(count => {
            console.log(`::set-output name=correlations-generated::${count}`);
          }).catch(console.error);
          EOF
          
          node generate-correlations.js
      
      - name: 📊 Generate Data Summary Report
        id: summary
        run: |
          cat > data-summary.md << 'EOF'
          # 📊 CorrelateAI Data Collection Report
          
          **Collection Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Workflow:** Automated Data Pipeline
          **Trigger:** ${{ github.event_name }}
          
          ## 📈 Data Collection Summary
          
          - **FRED Economic Data:** ${{ steps.collect-fred.outputs.datasets-updated || 0 }} datasets updated
          - **World Bank Data:** ${{ steps.collect-worldbank.outputs.datasets-updated || 0 }} datasets updated  
          - **Financial Data:** ${{ steps.collect-finance.outputs.datasets-updated || 0 }} datasets updated
          - **Total Datasets Indexed:** ${{ steps.generate-index.outputs.datasets-indexed || 0 }}
          - **Correlations Generated:** ${{ steps.correlations.outputs.correlations-generated || 0 }}
          
          ## 🎯 Data Quality
          
          - All data passed quality threshold of ${{ env.QUALITY_THRESHOLD }}
          - Data sources: FRED, World Bank, Alpha Vantage
          - Time range: 2010-2024 (where available)
          - Data format: JSON with metadata
          
          ## 🔗 Top Correlations Discovered
          
          New correlations will be available in the CorrelateAI application after deployment.
          
          ## 🚀 Next Update
          
          Next automated update scheduled for tomorrow at 6 AM UTC.
          
          ---
          *Generated by CorrelateAI Data Pipeline*
          EOF
          
          echo "📊 Data collection summary generated"
      
      - name: 🔄 Commit Updated Data
        id: commit-data
        run: |
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "CorrelateAI Data Pipeline"
          
          # Add all data files
          git add public/ai-data/
          git add data-summary.md
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No data changes to commit"
            echo "commit-sha=" >> $GITHUB_OUTPUT
          else
            # Commit with detailed message
            TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M UTC")
            DATASETS_UPDATED=${{ steps.generate-index.outputs.datasets-indexed || 0 }}
            CORRELATIONS_GENERATED=${{ steps.correlations.outputs.correlations-generated || 0 }}
            
            git commit -m "🤖 Automated data update - $TIMESTAMP
            
            📊 Updated $DATASETS_UPDATED datasets
            🔗 Generated $CORRELATIONS_GENERATED correlations
            
            Sources:
            - FRED: ${{ steps.collect-fred.outputs.datasets-updated || 0 }} datasets
            - World Bank: ${{ steps.collect-worldbank.outputs.datasets-updated || 0 }} datasets  
            - Financial: ${{ steps.collect-finance.outputs.datasets-updated || 0 }} datasets
            
            Generated by: GitHub Actions Data Pipeline
            Workflow: ${{ github.workflow }}
            Run: ${{ github.run_number }}"
            
            git push
            
            echo "commit-sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
            echo "✅ Data committed and pushed to repository"
          fi
      
      - name: 📱 Create Issue on Errors
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 Automated Data Collection Failed',
              body: `The automated data collection workflow failed on ${new Date().toISOString()}.
              
              **Workflow Run:** ${{ github.run_id }}
              **Trigger:** ${{ github.event_name }}
              **Branch:** ${{ github.ref }}
              
              Please check the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.
              
              Common issues:
              - API rate limits exceeded
              - API keys expired or invalid
              - Network connectivity issues
              - Data source changes
              
              Labels: bug, automation`,
              labels: ['bug', 'automation']
            })

  deploy-update:
    name: 🚀 Deploy Updated Data
    needs: collect-data
    runs-on: ubuntu-latest
    if: needs.collect-data.outputs.data-commit-sha != ''
    
    steps:
      - name: 🎉 Data Collection Success
        run: |
          echo "🎉 Data collection completed successfully!"
          echo "📊 Datasets updated: ${{ needs.collect-data.outputs.datasets-updated }}"
          echo "🔗 Correlations generated: ${{ needs.collect-data.outputs.correlations-generated }}"
          echo "📝 Commit SHA: ${{ needs.collect-data.outputs.data-commit-sha }}"
      
      - name: 🌐 Trigger Deployment (if configured)
        if: github.event_name == 'schedule' && github.ref == 'refs/heads/main'
        run: |
          echo "🚀 Production deployment would be triggered here"
          echo "You can add your deployment webhook or action here"
          # Example: Trigger Vercel, Netlify, or other deployment
          # curl -X POST "${{ secrets.DEPLOY_WEBHOOK_URL }}"